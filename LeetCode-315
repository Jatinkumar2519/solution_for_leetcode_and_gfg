class Solution {
public:
    class SegmentTree{
    public:
        vector<int> tree;
        SegmentTree(int n){
            tree.resize(4 * n);
        }
        void update(int node,int indx,int l,int r){
            if(indx < l || r < indx) return;
            if(l == r){
                tree[node]++;
                return;
            }
            int mid = (l + r) >> 1;
            int left = (node << 1) + 1;
            int right = (node << 1) + 2;
            if(indx <= mid){
                update(left,indx,l,mid);
            }
            else{
                update(right,indx,mid + 1,r);
            }
            tree[node] = tree[left] + tree[right];
        }
        int query(int node,int ql,int qr,int l,int r){
            if(qr < l || r < ql) return 0;
            if(ql <= l && r <= qr) return tree[node];
            int mid = (l + r) >> 1;
            int left = (node << 1) + 1;
            int right = (node << 1) + 2;
            return query(left,ql,qr,l,mid) + query(right,ql,qr,mid + 1,r);
        }
    };
    vector<int> countSmaller(vector<int>& nums) {
        vector<int> sorted(nums.begin(),nums.end());
        sort(sorted.begin(),sorted.end());
        sorted.erase(unique(sorted.begin(),sorted.end()),sorted.end());
        unordered_map<int,int> map;
        int n = sorted.size();
        SegmentTree segt(n);
        for(int i = 0;i < n;i++){
            map[sorted[i]] = i;
        }
        vector<int> result(nums.size());
        for(int i = nums.size() - 1;i >= 0;i--){
            if(map[nums[i]] == 0){
                result[i] = 0;
            }
            else{
                result[i] = segt.query(0,0,map[nums[i]] - 1,0,n - 1);
            }
            segt.update(0,map[nums[i]],0,n - 1);
        }
        return result;
    }
};
